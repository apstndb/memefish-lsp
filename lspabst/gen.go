// Code generated by hagane; DO NOT EDIT

package lspabst

import (
	"context"
	"log/slog"

	"github.com/apstndb/go-lsp-export/protocol"
)

var _ context.Context

// Check Can* interfaces are exhaustive
var _ protocol.Server = interface {
	CanCodeAction
	CanCodeLens
	CanColorPresentation
	CanCompletion
	CanDeclaration
	CanDefinition
	CanDiagnostic
	CanDiagnosticWorkspace
	CanDidChange
	CanDidChangeConfiguration
	CanDidChangeNotebookDocument
	CanDidChangeWatchedFiles
	CanDidChangeWorkspaceFolders
	CanDidClose
	CanDidCloseNotebookDocument
	CanDidCreateFiles
	CanDidDeleteFiles
	CanDidOpen
	CanDidOpenNotebookDocument
	CanDidRenameFiles
	CanDidSave
	CanDidSaveNotebookDocument
	CanDocumentColor
	CanDocumentHighlight
	CanDocumentLink
	CanDocumentSymbol
	CanExecuteCommand
	CanExit
	CanFoldingRange
	CanFormatting
	CanHover
	CanImplementation
	CanIncomingCalls
	CanInitialize
	CanInitialized
	CanInlayHint
	CanInlineCompletion
	CanInlineValue
	CanLinkedEditingRange
	CanMoniker
	CanOnTypeFormatting
	CanOutgoingCalls
	CanPrepareCallHierarchy
	CanPrepareRename
	CanPrepareTypeHierarchy
	CanProgress
	CanRangeFormatting
	CanRangesFormatting
	CanReferences
	CanRename
	CanResolve
	CanResolveCodeAction
	CanResolveCodeLens
	CanResolveCompletionItem
	CanResolveDocumentLink
	CanResolveWorkspaceSymbol
	CanSelectionRange
	CanSemanticTokensFull
	CanSemanticTokensFullDelta
	CanSemanticTokensRange
	CanSetTrace
	CanShutdown
	CanSignatureHelp
	CanSubtypes
	CanSupertypes
	CanSymbol
	CanTextDocumentContent
	CanTypeDefinition
	CanWillCreateFiles
	CanWillDeleteFiles
	CanWillRenameFiles
	CanWillSave
	CanWillSaveWaitUntil
	CanWorkDoneProgressCancel
}(nil)

// Generate Can* interfaces

type CanCodeAction interface {
	CodeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error)
}

type CanCodeLens interface {
	CodeLens(ctx context.Context, params *protocol.CodeLensParams) ([]protocol.CodeLens, error)
}

type CanColorPresentation interface {
	ColorPresentation(ctx context.Context, params *protocol.ColorPresentationParams) ([]protocol.ColorPresentation, error)
}

type CanCompletion interface {
	Completion(ctx context.Context, params *protocol.CompletionParams) (*protocol.CompletionList, error)
}

type CanDeclaration interface {
	Declaration(ctx context.Context, params *protocol.DeclarationParams) (*protocol.Or_textDocument_declaration, error)
}

type CanDefinition interface {
	Definition(ctx context.Context, params *protocol.DefinitionParams) ([]protocol.Location, error)
}

type CanDiagnostic interface {
	Diagnostic(ctx context.Context, params *protocol.DocumentDiagnosticParams) (*protocol.DocumentDiagnosticReport, error)
}

type CanDiagnosticWorkspace interface {
	DiagnosticWorkspace(ctx context.Context, params *protocol.WorkspaceDiagnosticParams) (*protocol.WorkspaceDiagnosticReport, error)
}

type CanDidChange interface {
	DidChange(ctx context.Context, params *protocol.DidChangeTextDocumentParams) error
}

type CanDidChangeConfiguration interface {
	DidChangeConfiguration(ctx context.Context, params *protocol.DidChangeConfigurationParams) error
}

type CanDidChangeNotebookDocument interface {
	DidChangeNotebookDocument(ctx context.Context, params *protocol.DidChangeNotebookDocumentParams) error
}

type CanDidChangeWatchedFiles interface {
	DidChangeWatchedFiles(ctx context.Context, params *protocol.DidChangeWatchedFilesParams) error
}

type CanDidChangeWorkspaceFolders interface {
	DidChangeWorkspaceFolders(ctx context.Context, params *protocol.DidChangeWorkspaceFoldersParams) error
}

type CanDidClose interface {
	DidClose(ctx context.Context, params *protocol.DidCloseTextDocumentParams) error
}

type CanDidCloseNotebookDocument interface {
	DidCloseNotebookDocument(ctx context.Context, params *protocol.DidCloseNotebookDocumentParams) error
}

type CanDidCreateFiles interface {
	DidCreateFiles(ctx context.Context, params *protocol.CreateFilesParams) error
}

type CanDidDeleteFiles interface {
	DidDeleteFiles(ctx context.Context, params *protocol.DeleteFilesParams) error
}

type CanDidOpen interface {
	DidOpen(ctx context.Context, params *protocol.DidOpenTextDocumentParams) error
}

type CanDidOpenNotebookDocument interface {
	DidOpenNotebookDocument(ctx context.Context, params *protocol.DidOpenNotebookDocumentParams) error
}

type CanDidRenameFiles interface {
	DidRenameFiles(ctx context.Context, params *protocol.RenameFilesParams) error
}

type CanDidSave interface {
	DidSave(ctx context.Context, params *protocol.DidSaveTextDocumentParams) error
}

type CanDidSaveNotebookDocument interface {
	DidSaveNotebookDocument(ctx context.Context, params *protocol.DidSaveNotebookDocumentParams) error
}

type CanDocumentColor interface {
	DocumentColor(ctx context.Context, params *protocol.DocumentColorParams) ([]protocol.ColorInformation, error)
}

type CanDocumentHighlight interface {
	DocumentHighlight(ctx context.Context, params *protocol.DocumentHighlightParams) ([]protocol.DocumentHighlight, error)
}

type CanDocumentLink interface {
	DocumentLink(ctx context.Context, params *protocol.DocumentLinkParams) ([]protocol.DocumentLink, error)
}

type CanDocumentSymbol interface {
	DocumentSymbol(ctx context.Context, params *protocol.DocumentSymbolParams) ([]interface{}, error)
}

type CanExecuteCommand interface {
	ExecuteCommand(ctx context.Context, params *protocol.ExecuteCommandParams) (interface{}, error)
}

type CanExit interface {
	Exit(ctx context.Context) error
}

type CanFoldingRange interface {
	FoldingRange(ctx context.Context, params *protocol.FoldingRangeParams) ([]protocol.FoldingRange, error)
}

type CanFormatting interface {
	Formatting(ctx context.Context, params *protocol.DocumentFormattingParams) ([]protocol.TextEdit, error)
}

type CanHover interface {
	Hover(ctx context.Context, params *protocol.HoverParams) (*protocol.Hover, error)
}

type CanImplementation interface {
	Implementation(ctx context.Context, params *protocol.ImplementationParams) ([]protocol.Location, error)
}

type CanIncomingCalls interface {
	IncomingCalls(ctx context.Context, params *protocol.CallHierarchyIncomingCallsParams) ([]protocol.CallHierarchyIncomingCall, error)
}

type CanInitialize interface {
	Initialize(ctx context.Context, params *protocol.ParamInitialize) (*protocol.InitializeResult, error)
}

type CanInitialized interface {
	Initialized(ctx context.Context, params *protocol.InitializedParams) error
}

type CanInlayHint interface {
	InlayHint(ctx context.Context, params *protocol.InlayHintParams) ([]protocol.InlayHint, error)
}

type CanInlineCompletion interface {
	InlineCompletion(ctx context.Context, params *protocol.InlineCompletionParams) (*protocol.Or_Result_textDocument_inlineCompletion, error)
}

type CanInlineValue interface {
	InlineValue(ctx context.Context, params *protocol.InlineValueParams) ([]protocol.InlineValue, error)
}

type CanLinkedEditingRange interface {
	LinkedEditingRange(ctx context.Context, params *protocol.LinkedEditingRangeParams) (*protocol.LinkedEditingRanges, error)
}

type CanMoniker interface {
	Moniker(ctx context.Context, params *protocol.MonikerParams) ([]protocol.Moniker, error)
}

type CanOnTypeFormatting interface {
	OnTypeFormatting(ctx context.Context, params *protocol.DocumentOnTypeFormattingParams) ([]protocol.TextEdit, error)
}

type CanOutgoingCalls interface {
	OutgoingCalls(ctx context.Context, params *protocol.CallHierarchyOutgoingCallsParams) ([]protocol.CallHierarchyOutgoingCall, error)
}

type CanPrepareCallHierarchy interface {
	PrepareCallHierarchy(ctx context.Context, params *protocol.CallHierarchyPrepareParams) ([]protocol.CallHierarchyItem, error)
}

type CanPrepareRename interface {
	PrepareRename(ctx context.Context, params *protocol.PrepareRenameParams) (*protocol.PrepareRenameResult, error)
}

type CanPrepareTypeHierarchy interface {
	PrepareTypeHierarchy(ctx context.Context, params *protocol.TypeHierarchyPrepareParams) ([]protocol.TypeHierarchyItem, error)
}

type CanProgress interface {
	Progress(ctx context.Context, params *protocol.ProgressParams) error
}

type CanRangeFormatting interface {
	RangeFormatting(ctx context.Context, params *protocol.DocumentRangeFormattingParams) ([]protocol.TextEdit, error)
}

type CanRangesFormatting interface {
	RangesFormatting(ctx context.Context, params *protocol.DocumentRangesFormattingParams) ([]protocol.TextEdit, error)
}

type CanReferences interface {
	References(ctx context.Context, params *protocol.ReferenceParams) ([]protocol.Location, error)
}

type CanRename interface {
	Rename(ctx context.Context, params *protocol.RenameParams) (*protocol.WorkspaceEdit, error)
}

type CanResolve interface {
	Resolve(ctx context.Context, params *protocol.InlayHint) (*protocol.InlayHint, error)
}

type CanResolveCodeAction interface {
	ResolveCodeAction(ctx context.Context, params *protocol.CodeAction) (*protocol.CodeAction, error)
}

type CanResolveCodeLens interface {
	ResolveCodeLens(ctx context.Context, params *protocol.CodeLens) (*protocol.CodeLens, error)
}

type CanResolveCompletionItem interface {
	ResolveCompletionItem(ctx context.Context, params *protocol.CompletionItem) (*protocol.CompletionItem, error)
}

type CanResolveDocumentLink interface {
	ResolveDocumentLink(ctx context.Context, params *protocol.DocumentLink) (*protocol.DocumentLink, error)
}

type CanResolveWorkspaceSymbol interface {
	ResolveWorkspaceSymbol(ctx context.Context, params *protocol.WorkspaceSymbol) (*protocol.WorkspaceSymbol, error)
}

type CanSelectionRange interface {
	SelectionRange(ctx context.Context, params *protocol.SelectionRangeParams) ([]protocol.SelectionRange, error)
}

type CanSemanticTokensFull interface {
	SemanticTokensFull(ctx context.Context, params *protocol.SemanticTokensParams) (*protocol.SemanticTokens, error)
}

type CanSemanticTokensFullDelta interface {
	SemanticTokensFullDelta(ctx context.Context, params *protocol.SemanticTokensDeltaParams) (interface{}, error)
}

type CanSemanticTokensRange interface {
	SemanticTokensRange(ctx context.Context, params *protocol.SemanticTokensRangeParams) (*protocol.SemanticTokens, error)
}

type CanSetTrace interface {
	SetTrace(ctx context.Context, params *protocol.SetTraceParams) error
}

type CanShutdown interface {
	Shutdown(ctx context.Context) error
}

type CanSignatureHelp interface {
	SignatureHelp(ctx context.Context, params *protocol.SignatureHelpParams) (*protocol.SignatureHelp, error)
}

type CanSubtypes interface {
	Subtypes(ctx context.Context, params *protocol.TypeHierarchySubtypesParams) ([]protocol.TypeHierarchyItem, error)
}

type CanSupertypes interface {
	Supertypes(ctx context.Context, params *protocol.TypeHierarchySupertypesParams) ([]protocol.TypeHierarchyItem, error)
}

type CanSymbol interface {
	Symbol(ctx context.Context, params *protocol.WorkspaceSymbolParams) ([]protocol.SymbolInformation, error)
}

type CanTextDocumentContent interface {
	TextDocumentContent(ctx context.Context, params *protocol.TextDocumentContentParams) (*string, error)
}

type CanTypeDefinition interface {
	TypeDefinition(ctx context.Context, params *protocol.TypeDefinitionParams) ([]protocol.Location, error)
}

type CanWillCreateFiles interface {
	WillCreateFiles(ctx context.Context, params *protocol.CreateFilesParams) (*protocol.WorkspaceEdit, error)
}

type CanWillDeleteFiles interface {
	WillDeleteFiles(ctx context.Context, params *protocol.DeleteFilesParams) (*protocol.WorkspaceEdit, error)
}

type CanWillRenameFiles interface {
	WillRenameFiles(ctx context.Context, params *protocol.RenameFilesParams) (*protocol.WorkspaceEdit, error)
}

type CanWillSave interface {
	WillSave(ctx context.Context, params *protocol.WillSaveTextDocumentParams) error
}

type CanWillSaveWaitUntil interface {
	WillSaveWaitUntil(ctx context.Context, params *protocol.WillSaveTextDocumentParams) ([]protocol.TextEdit, error)
}

type CanWorkDoneProgressCancel interface {
	WorkDoneProgressCancel(ctx context.Context, params *protocol.WorkDoneProgressCancelParams) error
}

// Generate wrapper methods for *Wrapper

func (s *Wrapper) CodeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	s.logger.Info("CodeAction", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanCodeAction); !ok {
		return nil, nil
	} else {
		return s.CodeAction(ctx, params)
	}
}

func (s *Wrapper) CodeLens(ctx context.Context, params *protocol.CodeLensParams) ([]protocol.CodeLens, error) {
	s.logger.Info("CodeLens", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanCodeLens); !ok {
		return nil, nil
	} else {
		return s.CodeLens(ctx, params)
	}
}

func (s *Wrapper) ColorPresentation(ctx context.Context, params *protocol.ColorPresentationParams) ([]protocol.ColorPresentation, error) {
	s.logger.Info("ColorPresentation", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanColorPresentation); !ok {
		return nil, nil
	} else {
		return s.ColorPresentation(ctx, params)
	}
}

func (s *Wrapper) Completion(ctx context.Context, params *protocol.CompletionParams) (*protocol.CompletionList, error) {
	s.logger.Info("Completion", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanCompletion); !ok {
		return nil, nil
	} else {
		return s.Completion(ctx, params)
	}
}

func (s *Wrapper) Declaration(ctx context.Context, params *protocol.DeclarationParams) (*protocol.Or_textDocument_declaration, error) {
	s.logger.Info("Declaration", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDeclaration); !ok {
		return nil, nil
	} else {
		return s.Declaration(ctx, params)
	}
}

func (s *Wrapper) Definition(ctx context.Context, params *protocol.DefinitionParams) ([]protocol.Location, error) {
	s.logger.Info("Definition", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDefinition); !ok {
		return nil, nil
	} else {
		return s.Definition(ctx, params)
	}
}

func (s *Wrapper) Diagnostic(ctx context.Context, params *protocol.DocumentDiagnosticParams) (*protocol.DocumentDiagnosticReport, error) {
	s.logger.Info("Diagnostic", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDiagnostic); !ok {
		return nil, nil
	} else {
		return s.Diagnostic(ctx, params)
	}
}

func (s *Wrapper) DiagnosticWorkspace(ctx context.Context, params *protocol.WorkspaceDiagnosticParams) (*protocol.WorkspaceDiagnosticReport, error) {
	s.logger.Info("DiagnosticWorkspace", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDiagnosticWorkspace); !ok {
		return nil, nil
	} else {
		return s.DiagnosticWorkspace(ctx, params)
	}
}

func (s *Wrapper) DidChange(ctx context.Context, params *protocol.DidChangeTextDocumentParams) error {
	s.logger.Info("DidChange", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidChange); !ok {
		return nil
	} else {
		return s.DidChange(ctx, params)
	}
}

func (s *Wrapper) DidChangeConfiguration(ctx context.Context, params *protocol.DidChangeConfigurationParams) error {
	s.logger.Info("DidChangeConfiguration", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidChangeConfiguration); !ok {
		return nil
	} else {
		return s.DidChangeConfiguration(ctx, params)
	}
}

func (s *Wrapper) DidChangeNotebookDocument(ctx context.Context, params *protocol.DidChangeNotebookDocumentParams) error {
	s.logger.Info("DidChangeNotebookDocument", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidChangeNotebookDocument); !ok {
		return nil
	} else {
		return s.DidChangeNotebookDocument(ctx, params)
	}
}

func (s *Wrapper) DidChangeWatchedFiles(ctx context.Context, params *protocol.DidChangeWatchedFilesParams) error {
	s.logger.Info("DidChangeWatchedFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidChangeWatchedFiles); !ok {
		return nil
	} else {
		return s.DidChangeWatchedFiles(ctx, params)
	}
}

func (s *Wrapper) DidChangeWorkspaceFolders(ctx context.Context, params *protocol.DidChangeWorkspaceFoldersParams) error {
	s.logger.Info("DidChangeWorkspaceFolders", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidChangeWorkspaceFolders); !ok {
		return nil
	} else {
		return s.DidChangeWorkspaceFolders(ctx, params)
	}
}

func (s *Wrapper) DidClose(ctx context.Context, params *protocol.DidCloseTextDocumentParams) error {
	s.logger.Info("DidClose", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidClose); !ok {
		return nil
	} else {
		return s.DidClose(ctx, params)
	}
}

func (s *Wrapper) DidCloseNotebookDocument(ctx context.Context, params *protocol.DidCloseNotebookDocumentParams) error {
	s.logger.Info("DidCloseNotebookDocument", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidCloseNotebookDocument); !ok {
		return nil
	} else {
		return s.DidCloseNotebookDocument(ctx, params)
	}
}

func (s *Wrapper) DidCreateFiles(ctx context.Context, params *protocol.CreateFilesParams) error {
	s.logger.Info("DidCreateFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidCreateFiles); !ok {
		return nil
	} else {
		return s.DidCreateFiles(ctx, params)
	}
}

func (s *Wrapper) DidDeleteFiles(ctx context.Context, params *protocol.DeleteFilesParams) error {
	s.logger.Info("DidDeleteFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidDeleteFiles); !ok {
		return nil
	} else {
		return s.DidDeleteFiles(ctx, params)
	}
}

func (s *Wrapper) DidOpen(ctx context.Context, params *protocol.DidOpenTextDocumentParams) error {
	s.logger.Info("DidOpen", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidOpen); !ok {
		return nil
	} else {
		return s.DidOpen(ctx, params)
	}
}

func (s *Wrapper) DidOpenNotebookDocument(ctx context.Context, params *protocol.DidOpenNotebookDocumentParams) error {
	s.logger.Info("DidOpenNotebookDocument", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidOpenNotebookDocument); !ok {
		return nil
	} else {
		return s.DidOpenNotebookDocument(ctx, params)
	}
}

func (s *Wrapper) DidRenameFiles(ctx context.Context, params *protocol.RenameFilesParams) error {
	s.logger.Info("DidRenameFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidRenameFiles); !ok {
		return nil
	} else {
		return s.DidRenameFiles(ctx, params)
	}
}

func (s *Wrapper) DidSave(ctx context.Context, params *protocol.DidSaveTextDocumentParams) error {
	s.logger.Info("DidSave", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidSave); !ok {
		return nil
	} else {
		return s.DidSave(ctx, params)
	}
}

func (s *Wrapper) DidSaveNotebookDocument(ctx context.Context, params *protocol.DidSaveNotebookDocumentParams) error {
	s.logger.Info("DidSaveNotebookDocument", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDidSaveNotebookDocument); !ok {
		return nil
	} else {
		return s.DidSaveNotebookDocument(ctx, params)
	}
}

func (s *Wrapper) DocumentColor(ctx context.Context, params *protocol.DocumentColorParams) ([]protocol.ColorInformation, error) {
	s.logger.Info("DocumentColor", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDocumentColor); !ok {
		return nil, nil
	} else {
		return s.DocumentColor(ctx, params)
	}
}

func (s *Wrapper) DocumentHighlight(ctx context.Context, params *protocol.DocumentHighlightParams) ([]protocol.DocumentHighlight, error) {
	s.logger.Info("DocumentHighlight", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDocumentHighlight); !ok {
		return nil, nil
	} else {
		return s.DocumentHighlight(ctx, params)
	}
}

func (s *Wrapper) DocumentLink(ctx context.Context, params *protocol.DocumentLinkParams) ([]protocol.DocumentLink, error) {
	s.logger.Info("DocumentLink", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDocumentLink); !ok {
		return nil, nil
	} else {
		return s.DocumentLink(ctx, params)
	}
}

func (s *Wrapper) DocumentSymbol(ctx context.Context, params *protocol.DocumentSymbolParams) ([]interface{}, error) {
	s.logger.Info("DocumentSymbol", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanDocumentSymbol); !ok {
		return nil, nil
	} else {
		return s.DocumentSymbol(ctx, params)
	}
}

func (s *Wrapper) ExecuteCommand(ctx context.Context, params *protocol.ExecuteCommandParams) (interface{}, error) {
	s.logger.Info("ExecuteCommand", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanExecuteCommand); !ok {
		return nil, nil
	} else {
		return s.ExecuteCommand(ctx, params)
	}
}

func (s *Wrapper) Exit(ctx context.Context) error {
	s.logger.Info("Exit", slog.Any("ctx", ctx))
	if s, ok := s.handler.(CanExit); !ok {
		return nil
	} else {
		return s.Exit(ctx)
	}
}

func (s *Wrapper) FoldingRange(ctx context.Context, params *protocol.FoldingRangeParams) ([]protocol.FoldingRange, error) {
	s.logger.Info("FoldingRange", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanFoldingRange); !ok {
		return nil, nil
	} else {
		return s.FoldingRange(ctx, params)
	}
}

func (s *Wrapper) Formatting(ctx context.Context, params *protocol.DocumentFormattingParams) ([]protocol.TextEdit, error) {
	s.logger.Info("Formatting", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanFormatting); !ok {
		return nil, nil
	} else {
		return s.Formatting(ctx, params)
	}
}

func (s *Wrapper) Hover(ctx context.Context, params *protocol.HoverParams) (*protocol.Hover, error) {
	s.logger.Info("Hover", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanHover); !ok {
		return nil, nil
	} else {
		return s.Hover(ctx, params)
	}
}

func (s *Wrapper) Implementation(ctx context.Context, params *protocol.ImplementationParams) ([]protocol.Location, error) {
	s.logger.Info("Implementation", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanImplementation); !ok {
		return nil, nil
	} else {
		return s.Implementation(ctx, params)
	}
}

func (s *Wrapper) IncomingCalls(ctx context.Context, params *protocol.CallHierarchyIncomingCallsParams) ([]protocol.CallHierarchyIncomingCall, error) {
	s.logger.Info("IncomingCalls", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanIncomingCalls); !ok {
		return nil, nil
	} else {
		return s.IncomingCalls(ctx, params)
	}
}

func (s *Wrapper) Initialize(ctx context.Context, params *protocol.ParamInitialize) (*protocol.InitializeResult, error) {
	s.logger.Info("Initialize", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanInitialize); !ok {
		return nil, nil
	} else {
		return s.Initialize(ctx, params)
	}
}

func (s *Wrapper) Initialized(ctx context.Context, params *protocol.InitializedParams) error {
	s.logger.Info("Initialized", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanInitialized); !ok {
		return nil
	} else {
		return s.Initialized(ctx, params)
	}
}

func (s *Wrapper) InlayHint(ctx context.Context, params *protocol.InlayHintParams) ([]protocol.InlayHint, error) {
	s.logger.Info("InlayHint", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanInlayHint); !ok {
		return nil, nil
	} else {
		return s.InlayHint(ctx, params)
	}
}

func (s *Wrapper) InlineCompletion(ctx context.Context, params *protocol.InlineCompletionParams) (*protocol.Or_Result_textDocument_inlineCompletion, error) {
	s.logger.Info("InlineCompletion", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanInlineCompletion); !ok {
		return nil, nil
	} else {
		return s.InlineCompletion(ctx, params)
	}
}

func (s *Wrapper) InlineValue(ctx context.Context, params *protocol.InlineValueParams) ([]protocol.InlineValue, error) {
	s.logger.Info("InlineValue", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanInlineValue); !ok {
		return nil, nil
	} else {
		return s.InlineValue(ctx, params)
	}
}

func (s *Wrapper) LinkedEditingRange(ctx context.Context, params *protocol.LinkedEditingRangeParams) (*protocol.LinkedEditingRanges, error) {
	s.logger.Info("LinkedEditingRange", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanLinkedEditingRange); !ok {
		return nil, nil
	} else {
		return s.LinkedEditingRange(ctx, params)
	}
}

func (s *Wrapper) Moniker(ctx context.Context, params *protocol.MonikerParams) ([]protocol.Moniker, error) {
	s.logger.Info("Moniker", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanMoniker); !ok {
		return nil, nil
	} else {
		return s.Moniker(ctx, params)
	}
}

func (s *Wrapper) OnTypeFormatting(ctx context.Context, params *protocol.DocumentOnTypeFormattingParams) ([]protocol.TextEdit, error) {
	s.logger.Info("OnTypeFormatting", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanOnTypeFormatting); !ok {
		return nil, nil
	} else {
		return s.OnTypeFormatting(ctx, params)
	}
}

func (s *Wrapper) OutgoingCalls(ctx context.Context, params *protocol.CallHierarchyOutgoingCallsParams) ([]protocol.CallHierarchyOutgoingCall, error) {
	s.logger.Info("OutgoingCalls", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanOutgoingCalls); !ok {
		return nil, nil
	} else {
		return s.OutgoingCalls(ctx, params)
	}
}

func (s *Wrapper) PrepareCallHierarchy(ctx context.Context, params *protocol.CallHierarchyPrepareParams) ([]protocol.CallHierarchyItem, error) {
	s.logger.Info("PrepareCallHierarchy", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanPrepareCallHierarchy); !ok {
		return nil, nil
	} else {
		return s.PrepareCallHierarchy(ctx, params)
	}
}

func (s *Wrapper) PrepareRename(ctx context.Context, params *protocol.PrepareRenameParams) (*protocol.PrepareRenameResult, error) {
	s.logger.Info("PrepareRename", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanPrepareRename); !ok {
		return nil, nil
	} else {
		return s.PrepareRename(ctx, params)
	}
}

func (s *Wrapper) PrepareTypeHierarchy(ctx context.Context, params *protocol.TypeHierarchyPrepareParams) ([]protocol.TypeHierarchyItem, error) {
	s.logger.Info("PrepareTypeHierarchy", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanPrepareTypeHierarchy); !ok {
		return nil, nil
	} else {
		return s.PrepareTypeHierarchy(ctx, params)
	}
}

func (s *Wrapper) Progress(ctx context.Context, params *protocol.ProgressParams) error {
	s.logger.Info("Progress", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanProgress); !ok {
		return nil
	} else {
		return s.Progress(ctx, params)
	}
}

func (s *Wrapper) RangeFormatting(ctx context.Context, params *protocol.DocumentRangeFormattingParams) ([]protocol.TextEdit, error) {
	s.logger.Info("RangeFormatting", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanRangeFormatting); !ok {
		return nil, nil
	} else {
		return s.RangeFormatting(ctx, params)
	}
}

func (s *Wrapper) RangesFormatting(ctx context.Context, params *protocol.DocumentRangesFormattingParams) ([]protocol.TextEdit, error) {
	s.logger.Info("RangesFormatting", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanRangesFormatting); !ok {
		return nil, nil
	} else {
		return s.RangesFormatting(ctx, params)
	}
}

func (s *Wrapper) References(ctx context.Context, params *protocol.ReferenceParams) ([]protocol.Location, error) {
	s.logger.Info("References", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanReferences); !ok {
		return nil, nil
	} else {
		return s.References(ctx, params)
	}
}

func (s *Wrapper) Rename(ctx context.Context, params *protocol.RenameParams) (*protocol.WorkspaceEdit, error) {
	s.logger.Info("Rename", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanRename); !ok {
		return nil, nil
	} else {
		return s.Rename(ctx, params)
	}
}

func (s *Wrapper) Resolve(ctx context.Context, params *protocol.InlayHint) (*protocol.InlayHint, error) {
	s.logger.Info("Resolve", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanResolve); !ok {
		return nil, nil
	} else {
		return s.Resolve(ctx, params)
	}
}

func (s *Wrapper) ResolveCodeAction(ctx context.Context, params *protocol.CodeAction) (*protocol.CodeAction, error) {
	s.logger.Info("ResolveCodeAction", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanResolveCodeAction); !ok {
		return nil, nil
	} else {
		return s.ResolveCodeAction(ctx, params)
	}
}

func (s *Wrapper) ResolveCodeLens(ctx context.Context, params *protocol.CodeLens) (*protocol.CodeLens, error) {
	s.logger.Info("ResolveCodeLens", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanResolveCodeLens); !ok {
		return nil, nil
	} else {
		return s.ResolveCodeLens(ctx, params)
	}
}

func (s *Wrapper) ResolveCompletionItem(ctx context.Context, params *protocol.CompletionItem) (*protocol.CompletionItem, error) {
	s.logger.Info("ResolveCompletionItem", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanResolveCompletionItem); !ok {
		return nil, nil
	} else {
		return s.ResolveCompletionItem(ctx, params)
	}
}

func (s *Wrapper) ResolveDocumentLink(ctx context.Context, params *protocol.DocumentLink) (*protocol.DocumentLink, error) {
	s.logger.Info("ResolveDocumentLink", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanResolveDocumentLink); !ok {
		return nil, nil
	} else {
		return s.ResolveDocumentLink(ctx, params)
	}
}

func (s *Wrapper) ResolveWorkspaceSymbol(ctx context.Context, params *protocol.WorkspaceSymbol) (*protocol.WorkspaceSymbol, error) {
	s.logger.Info("ResolveWorkspaceSymbol", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanResolveWorkspaceSymbol); !ok {
		return nil, nil
	} else {
		return s.ResolveWorkspaceSymbol(ctx, params)
	}
}

func (s *Wrapper) SelectionRange(ctx context.Context, params *protocol.SelectionRangeParams) ([]protocol.SelectionRange, error) {
	s.logger.Info("SelectionRange", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSelectionRange); !ok {
		return nil, nil
	} else {
		return s.SelectionRange(ctx, params)
	}
}

func (s *Wrapper) SemanticTokensFull(ctx context.Context, params *protocol.SemanticTokensParams) (*protocol.SemanticTokens, error) {
	s.logger.Info("SemanticTokensFull", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSemanticTokensFull); !ok {
		return nil, nil
	} else {
		return s.SemanticTokensFull(ctx, params)
	}
}

func (s *Wrapper) SemanticTokensFullDelta(ctx context.Context, params *protocol.SemanticTokensDeltaParams) (interface{}, error) {
	s.logger.Info("SemanticTokensFullDelta", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSemanticTokensFullDelta); !ok {
		return nil, nil
	} else {
		return s.SemanticTokensFullDelta(ctx, params)
	}
}

func (s *Wrapper) SemanticTokensRange(ctx context.Context, params *protocol.SemanticTokensRangeParams) (*protocol.SemanticTokens, error) {
	s.logger.Info("SemanticTokensRange", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSemanticTokensRange); !ok {
		return nil, nil
	} else {
		return s.SemanticTokensRange(ctx, params)
	}
}

func (s *Wrapper) SetTrace(ctx context.Context, params *protocol.SetTraceParams) error {
	s.logger.Info("SetTrace", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSetTrace); !ok {
		return nil
	} else {
		return s.SetTrace(ctx, params)
	}
}

func (s *Wrapper) Shutdown(ctx context.Context) error {
	s.logger.Info("Shutdown", slog.Any("ctx", ctx))
	if s, ok := s.handler.(CanShutdown); !ok {
		return nil
	} else {
		return s.Shutdown(ctx)
	}
}

func (s *Wrapper) SignatureHelp(ctx context.Context, params *protocol.SignatureHelpParams) (*protocol.SignatureHelp, error) {
	s.logger.Info("SignatureHelp", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSignatureHelp); !ok {
		return nil, nil
	} else {
		return s.SignatureHelp(ctx, params)
	}
}

func (s *Wrapper) Subtypes(ctx context.Context, params *protocol.TypeHierarchySubtypesParams) ([]protocol.TypeHierarchyItem, error) {
	s.logger.Info("Subtypes", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSubtypes); !ok {
		return nil, nil
	} else {
		return s.Subtypes(ctx, params)
	}
}

func (s *Wrapper) Supertypes(ctx context.Context, params *protocol.TypeHierarchySupertypesParams) ([]protocol.TypeHierarchyItem, error) {
	s.logger.Info("Supertypes", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSupertypes); !ok {
		return nil, nil
	} else {
		return s.Supertypes(ctx, params)
	}
}

func (s *Wrapper) Symbol(ctx context.Context, params *protocol.WorkspaceSymbolParams) ([]protocol.SymbolInformation, error) {
	s.logger.Info("Symbol", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanSymbol); !ok {
		return nil, nil
	} else {
		return s.Symbol(ctx, params)
	}
}

func (s *Wrapper) TextDocumentContent(ctx context.Context, params *protocol.TextDocumentContentParams) (*string, error) {
	s.logger.Info("TextDocumentContent", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanTextDocumentContent); !ok {
		return nil, nil
	} else {
		return s.TextDocumentContent(ctx, params)
	}
}

func (s *Wrapper) TypeDefinition(ctx context.Context, params *protocol.TypeDefinitionParams) ([]protocol.Location, error) {
	s.logger.Info("TypeDefinition", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanTypeDefinition); !ok {
		return nil, nil
	} else {
		return s.TypeDefinition(ctx, params)
	}
}

func (s *Wrapper) WillCreateFiles(ctx context.Context, params *protocol.CreateFilesParams) (*protocol.WorkspaceEdit, error) {
	s.logger.Info("WillCreateFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanWillCreateFiles); !ok {
		return nil, nil
	} else {
		return s.WillCreateFiles(ctx, params)
	}
}

func (s *Wrapper) WillDeleteFiles(ctx context.Context, params *protocol.DeleteFilesParams) (*protocol.WorkspaceEdit, error) {
	s.logger.Info("WillDeleteFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanWillDeleteFiles); !ok {
		return nil, nil
	} else {
		return s.WillDeleteFiles(ctx, params)
	}
}

func (s *Wrapper) WillRenameFiles(ctx context.Context, params *protocol.RenameFilesParams) (*protocol.WorkspaceEdit, error) {
	s.logger.Info("WillRenameFiles", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanWillRenameFiles); !ok {
		return nil, nil
	} else {
		return s.WillRenameFiles(ctx, params)
	}
}

func (s *Wrapper) WillSave(ctx context.Context, params *protocol.WillSaveTextDocumentParams) error {
	s.logger.Info("WillSave", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanWillSave); !ok {
		return nil
	} else {
		return s.WillSave(ctx, params)
	}
}

func (s *Wrapper) WillSaveWaitUntil(ctx context.Context, params *protocol.WillSaveTextDocumentParams) ([]protocol.TextEdit, error) {
	s.logger.Info("WillSaveWaitUntil", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanWillSaveWaitUntil); !ok {
		return nil, nil
	} else {
		return s.WillSaveWaitUntil(ctx, params)
	}
}

func (s *Wrapper) WorkDoneProgressCancel(ctx context.Context, params *protocol.WorkDoneProgressCancelParams) error {
	s.logger.Info("WorkDoneProgressCancel", slog.Any("ctx", ctx), slog.Any("params", params))
	if s, ok := s.handler.(CanWorkDoneProgressCancel); !ok {
		return nil
	} else {
		return s.WorkDoneProgressCancel(ctx, params)
	}
}
